name: Deploy to ECS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Basic validation
      run: |
        echo "✅ Python version check:"
        python --version
        echo "✅ Requirements installed successfully"
        echo "✅ Code syntax validation:"
        python -m py_compile app/main.py
        echo "✅ All validations passed"

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Build Docker image
      run: |
        echo "🐳 Building Docker image..."
        docker build -f deploy/docker/Dockerfile.prod -t shop-sphere:latest .
        echo "✅ Docker image built successfully"
        
        # 保存镜像为tar文件
        docker save shop-sphere:latest | gzip > shop-sphere-image.tar.gz
        echo "✅ Docker image saved: $(ls -lh shop-sphere-image.tar.gz)"
    
    - name: Create deployment package
      run: |
        echo "📦 Creating deployment package..."
        # 创建部署包，包含现有的配置文件
        mkdir -p deploy-package
        cp deploy/docker/docker-compose.prod.yml deploy-package/
        cp -r deploy/nginx deploy-package/nginx
        cp -r deploy/supervisor deploy-package/supervisor
        cp deploy/scripts/configure-docker-mirrors.sh deploy-package/
        
        # 创建部署脚本
        cat > deploy-package/deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "🚀 开始部署到ECS服务器..."
        
        PROJECT_DIR="/opt/shop-sphere"
        
        # 检测容器运行时环境
        if command -v podman &> /dev/null; then
          echo "🐳 使用Podman环境"
          CONTAINER_CMD="podman"
          
          # 直接使用docker-compose通过Podman socket，避免podman-compose的Python版本问题
          COMPOSE_CMD="docker-compose"
          
          # 确保Podman socket可用
          echo "🔌 配置Podman socket..."
          sudo systemctl enable --now podman.socket || true
          sleep 3
          
          # 设置DOCKER_HOST环境变量
          export DOCKER_HOST="unix:///run/podman/podman.sock"
          
          # 验证连接
          if ! docker-compose version &> /dev/null; then
            echo "⚠️ docker-compose无法连接Podman socket，尝试创建链接..."
            sudo mkdir -p /var/run
            sudo ln -sf /run/podman/podman.sock /var/run/docker.sock || true
            unset DOCKER_HOST
          fi
        else
          echo "🐳 使用Docker环境"
          CONTAINER_CMD="docker"
          COMPOSE_CMD="docker-compose"
        fi
        
        echo "📦 使用容器命令: $CONTAINER_CMD, 编排命令: $COMPOSE_CMD"
        
        # 停止当前服务
        if [ -f $PROJECT_DIR/docker-compose.prod.yml ]; then
          echo "⏸️ 停止当前服务..."
          cd $PROJECT_DIR && $COMPOSE_CMD -f docker-compose.prod.yml down || true
        fi
        
        # 创建项目目录
        mkdir -p $PROJECT_DIR
        cd $PROJECT_DIR
        
        # 备份旧镜像
        if $CONTAINER_CMD images shop-sphere:latest -q | grep -q .; then
          echo "💾 备份旧镜像..."
          $CONTAINER_CMD tag shop-sphere:latest shop-sphere:backup-$(date +%Y%m%d_%H%M%S) || true
        fi
        
        # 加载新镜像
        echo "📦 加载新Docker镜像..."
        $CONTAINER_CMD load < /tmp/shop-sphere-image.tar.gz
        
        # 复制配置文件
        cp /tmp/deploy-package/docker-compose.prod.yml .
        cp -r /tmp/deploy-package/nginx .
        cp -r /tmp/deploy-package/supervisor .
        
        # 创建必要的目录
        mkdir -p uploads logs/nginx logs/supervisor mysql/conf.d redis
        
        # 创建环境变量文件
        echo "⚙️ 创建环境变量文件..."
        cat > .env << 'ENVEOF'
        # 数据库配置
        MYSQL_DATABASE=shopsphere
        MYSQL_USER=shopsphere
        MYSQL_PASSWORD=${MYSQL_PASSWORD}
        MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
        
        # OSS配置
        OSS_ACCESS_KEY_ID=${OSS_ACCESS_KEY_ID}
        OSS_ACCESS_KEY_SECRET=${OSS_ACCESS_KEY_SECRET}
        OSS_BUCKET_NAME=${OSS_BUCKET_NAME}
        OSS_ENDPOINT=${OSS_ENDPOINT}
        
        # JWT配置
        JWT_SECRET_KEY=${JWT_SECRET_KEY}
        
        # 应用配置
        ENVIRONMENT=production
        DEBUG=false
        HOST=0.0.0.0
        PORT=8000
        SERVER_ENVIRONMENT=PRODUCTION
        PYTHONPATH=/app
        ENVEOF
        
        # 替换环境变量占位符
        sed -i "s/\${MYSQL_PASSWORD}/$MYSQL_PASSWORD/g" .env
        sed -i "s/\${MYSQL_ROOT_PASSWORD}/$MYSQL_ROOT_PASSWORD/g" .env
        sed -i "s/\${OSS_ACCESS_KEY_ID}/$OSS_ACCESS_KEY_ID/g" .env
        sed -i "s/\${OSS_ACCESS_KEY_SECRET}/$OSS_ACCESS_KEY_SECRET/g" .env
        sed -i "s/\${OSS_BUCKET_NAME}/$OSS_BUCKET_NAME/g" .env
        sed -i "s/\${OSS_ENDPOINT}/$OSS_ENDPOINT/g" .env
        sed -i "s/\${JWT_SECRET_KEY}/$JWT_SECRET_KEY/g" .env
        
        # 启动服务
        echo "🚀 启动服务..."
        $COMPOSE_CMD -f docker-compose.prod.yml up -d
        
        # 等待服务启动
        echo "⏳ 等待服务启动..."
        sleep 30
        
        # 健康检查
        echo "🔍 执行健康检查..."
        for i in {1..12}; do
          if $COMPOSE_CMD -f docker-compose.prod.yml exec -T web curl -f http://localhost/health; then
            echo "✅ 服务启动成功！"
            break
          else
            echo "⏳ 等待服务启动... ($i/12)"
            sleep 10
          fi
          
          if [ $i -eq 12 ]; then
            echo "❌ 服务启动失败，查看日志："
            $COMPOSE_CMD -f docker-compose.prod.yml logs --tail=50
            exit 1
          fi
        done
        
        echo "🎉 部署完成！"
        $COMPOSE_CMD -f docker-compose.prod.yml ps
        EOF
        
        chmod +x deploy-package/deploy.sh
        
        # 打包配置文件
        tar -czf deploy-config.tar.gz -C deploy-package .
        echo "✅ Deployment package created: $(ls -lh deploy-config.tar.gz)"
    
    - name: Transfer Docker image to ECS
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ secrets.ECS_HOST }}
        username: ${{ secrets.ECS_USERNAME }}
        key: ${{ secrets.ECS_SSH_KEY }}
        source: "shop-sphere-image.tar.gz"
        target: "/tmp/"
        timeout: 600s
    
    - name: Transfer deployment package to ECS
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ secrets.ECS_HOST }}
        username: ${{ secrets.ECS_USERNAME }}
        key: ${{ secrets.ECS_SSH_KEY }}
        source: "deploy-config.tar.gz"
        target: "/tmp/"
    
    - name: Deploy to ECS
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.ECS_HOST }}
        username: ${{ secrets.ECS_USERNAME }}
        key: ${{ secrets.ECS_SSH_KEY }}
        timeout: 600s
        script: |
          # 初始化Podman环境（如果使用Podman）
          if command -v podman &> /dev/null; then
            echo "🔧 初始化Podman环境..."
            
            # 启动Podman socket服务
            echo "🔌 配置Podman socket服务..."
            sudo systemctl enable --now podman.socket || true
            
            # 等待socket启动
            sleep 5
            
            # 创建docker socket链接
            if [ ! -S /var/run/docker.sock ]; then
              sudo ln -sf /run/podman/podman.sock /var/run/docker.sock || true
            fi
            
            # 验证socket连接
            if sudo test -S /run/podman/podman.sock; then
              echo "✅ Podman socket服务已启动"
            else
              echo "⚠️ Podman socket服务启动失败，尝试用户模式..."
              systemctl --user enable --now podman.socket || true
            fi
            
            # 验证docker-compose可以通过socket工作
            echo "🔍 验证docker-compose与Podman的兼容性..."
            export DOCKER_HOST="unix:///run/podman/podman.sock"
            if docker-compose version; then
              echo "✅ docker-compose可以通过Podman socket工作"
            else
              echo "⚠️ 将使用直接的socket链接方式"
              unset DOCKER_HOST
            fi
          fi
          
          # 配置Docker镜像源（首次部署时）
          if [ ! -f /etc/docker/daemon.json ]; then
            echo "🔧 配置Docker镜像源..."
            mkdir -p /tmp/deploy-package
            cd /tmp
            tar -xzf deploy-config.tar.gz -C deploy-package
            chmod +x /tmp/deploy-package/configure-docker-mirrors.sh
            /tmp/deploy-package/configure-docker-mirrors.sh
          fi
          
          # 解压部署包
          mkdir -p /tmp/deploy-package
          cd /tmp
          tar -xzf deploy-config.tar.gz -C deploy-package
          
          # 设置环境变量并执行部署
          export MYSQL_PASSWORD="${{ secrets.DB_PASSWORD }}"
          export MYSQL_ROOT_PASSWORD="${{ secrets.DB_PASSWORD }}"
          export OSS_ACCESS_KEY_ID="${{ secrets.OSS_ACCESS_KEY_ID }}"
          export OSS_ACCESS_KEY_SECRET="${{ secrets.OSS_ACCESS_KEY_SECRET }}"
          export OSS_BUCKET_NAME="${{ secrets.OSS_BUCKET_NAME }}"
          export OSS_ENDPOINT="${{ secrets.OSS_ENDPOINT }}"
          export JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
          
          # 执行部署脚本
          /tmp/deploy-package/deploy.sh
          
          # 清理临时文件
          rm -f /tmp/shop-sphere-image.tar.gz
          rm -f /tmp/deploy-config.tar.gz
          rm -rf /tmp/deploy-package
          
          echo "🎉 部署完成！服务状态："
          cd /opt/shop-sphere
          
          # 检测容器运行时并显示服务状态
          if command -v podman &> /dev/null; then
            echo "🐳 使用Podman环境显示服务状态"
            export DOCKER_HOST="unix:///run/podman/podman.sock"
            docker-compose -f docker-compose.prod.yml ps || {
              echo "⚠️ 通过socket连接失败，尝试直接连接..."
              unset DOCKER_HOST
              docker-compose -f docker-compose.prod.yml ps
            }
          else
            docker-compose -f docker-compose.prod.yml ps
          fi 